# üìã ESTRATEGIA DE ORQUESTACI√ìN - PROYECTO CL√çNICA VETERINARIA

## üéØ OBJETIVO FINAL
Desplegar 3 aplicaciones dockerizadas en Azure, aprovechando el cr√©dito estudiantil, con arquitectura de microservicios orquestada.

---

## üìä ESTADO ACTUAL DEL PROYECTO

### ‚úÖ COMPLETADO
- **Backend (Spring Boot):** Dockerizado + MySQL funcionando
- **API REST:** 26 pruebas validadas exitosamente (CLIENTE, VETERINARIO, ADMIN)
- **Base de datos:** MySQL con datos de prueba cargados
- **Autenticaci√≥n:** JWT con roles implementados
- **Frontend:** C√≥digo existente + Dockerfile creado
- **Landing Page:** C√≥digo HTML est√°tico existente

### ‚ö†Ô∏è PENDIENTE
- **Conexi√≥n Frontend ‚Üî Backend** en contenedores Docker
- **Landing Page** redirigiendo a Frontend dockerizado
- **Docker Compose maestro** orquestando los 3 servicios
- **Variables de entorno** configuradas para producci√≥n
- **Despliegue en Azure** con servicios estudiantiles

---

## üöÄ FASES DE IMPLEMENTACI√ìN

---

## üìç FASE 1: INTEGRACI√ìN LOCAL CON DOCKER (HOY - 2-3 HORAS)

### üéØ Objetivo
Lograr que Frontend dockerizado se comunique con Backend dockerizado.

### üìù PROMPT PARA AGENTE FRONTEND

```markdown
# üöÄ TAREA: DOCKERIZAR Y CONECTAR FRONTEND CON BACKEND

## CONTEXTO ACTUAL
- Backend Spring Boot ya dockerizado: `http://localhost:8080/api`
- MySQL funcionando en Docker: puerto 3306
- 26 pruebas API exitosas validadas con Postman
- Frontend React con Vite existente en: `frontend-gestion-citas/`
- Dockerfile b√°sico ya creado pero sin configuraci√≥n de red

## OBJETIVO
Configurar el frontend para que funcione en Docker y se comunique con el backend dockerizado.

## TAREAS ESPEC√çFICAS

### 1. CONFIGURAR VARIABLES DE ENTORNO
Crear/modificar `.env` files:

**Para desarrollo local (sin Docker):**
```env
VITE_API_URL=http://localhost:8080/api
```

**Para Docker (desarrollo):**
```env
VITE_API_URL=http://backend:8080/api
```

**Para Azure (producci√≥n):**
```env
VITE_API_URL=https://backend-vetclinic.azurewebsites.net/api
```

### 2. ACTUALIZAR DOCKERFILE
Asegurar que el Dockerfile:
- Use node:18-alpine como base
- Copie package.json y package-lock.json
- Instale dependencias con `npm ci`
- Copie c√≥digo fuente
- Build la aplicaci√≥n con `npm run build`
- Use nginx para servir archivos est√°ticos
- Exponga puerto 80

### 3. CREAR DOCKER-COMPOSE LOCAL
Crear `docker-compose.dev.yml` en `frontend-gestion-citas/`:

```yaml
version: '3.8'

services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: vetclinic-frontend-dev
    ports:
      - "3000:80"
    environment:
      - VITE_API_URL=http://backend:8080/api
    networks:
      - vetclinic-network
    depends_on:
      - backend

  backend:
    image: gestion-citas-backend:latest
    container_name: vetclinic-backend-dev
    ports:
      - "8080:8080"
    networks:
      - vetclinic-network

networks:
  vetclinic-network:
    driver: bridge
```

### 4. CONFIGURAR NGINX
Crear `nginx.conf` en `frontend-gestion-citas/`:

```nginx
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 5. COMANDOS DE PRUEBA
```bash
# Build y levantar solo frontend
docker-compose -f docker-compose.dev.yml build frontend
docker-compose -f docker-compose.dev.yml up frontend

# Verificar que responde
curl http://localhost:3000

# Verificar logs
docker logs vetclinic-frontend-dev
```

## CRITERIOS DE √âXITO
- [ ] Frontend responde en `http://localhost:3000`
- [ ] P√°gina de login carga correctamente
- [ ] Al hacer login, el frontend puede autenticarse contra `http://backend:8080/api/auth/login`
- [ ] Dashboard carga datos desde el backend
- [ ] No hay errores de CORS
- [ ] Logs de Docker muestran comunicaci√≥n exitosa

## ENTREGABLES
1. `.env.development` y `.env.production` configurados
2. `Dockerfile` optimizado para producci√≥n
3. `nginx.conf` con proxy reverso
4. `docker-compose.dev.yml` funcional
5. Documentaci√≥n de comandos de prueba
6. Capturas de pantalla de frontend funcionando
```

---

### üìù PROMPT PARA LANDING PAGE

```markdown
# üöÄ TAREA: CONFIGURAR LANDING PAGE CON REDIRECCI√ìN

## CONTEXTO
- Landing page HTML/CSS/JS est√°tica en: `landing-page/`
- Frontend dockerizado corriendo en: `http://localhost:3000`
- Necesitamos que el bot√≥n "Acceder al Sistema" redirija correctamente

## OBJETIVO
Dockerizar la landing page y configurar redirecci√≥n al frontend.

## TAREAS ESPEC√çFICAS

### 1. ACTUALIZAR REDIRECCI√ìN EN HTML
Modificar `landing-page/index.html`:

```html
<!-- Bot√≥n de acceso -->
<a href="http://localhost:3000" 
   class="btn-primary" 
   id="btn-acceder">
  Acceder al Sistema
</a>

<script>
  // Configurar URL seg√∫n entorno
  const FRONTEND_URL = {
    development: 'http://localhost:3000',
    docker: 'http://frontend:3000',
    production: 'https://frontend-vetclinic.azurewebsites.net'
  };

  document.getElementById('btn-acceder').href = 
    FRONTEND_URL[process.env.NODE_ENV || 'development'];
</script>
```

### 2. CREAR DOCKERFILE
Crear `landing-page/Dockerfile`:

```dockerfile
FROM nginx:alpine

# Copiar archivos est√°ticos
COPY . /usr/share/nginx/html

# Copiar configuraci√≥n de nginx
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### 3. CONFIGURAR NGINX
Crear `landing-page/nginx.conf`:

```nginx
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

### 4. COMANDOS DE PRUEBA
```bash
# Build imagen
docker build -t vetclinic-landing:latest .

# Ejecutar contenedor
docker run -d -p 80:80 --name landing vetclinic-landing:latest

# Verificar
curl http://localhost
```

## CRITERIOS DE √âXITO
- [ ] Landing page carga en `http://localhost`
- [ ] Bot√≥n "Acceder" funciona correctamente
- [ ] Redirecci√≥n apunta a `http://localhost:3000`
- [ ] Estilos CSS se cargan correctamente
- [ ] Im√°genes se muestran correctamente

## ENTREGABLES
1. `Dockerfile` para landing page
2. `nginx.conf` configurado
3. HTML actualizado con redirecci√≥n din√°mica
4. Documentaci√≥n de comandos
```

---

## üìç FASE 2: ORQUESTACI√ìN COMPLETA (MA√ëANA - 2 HORAS)

### üéØ Objetivo
Crear docker-compose maestro que orqueste los 3 servicios: Backend + Frontend + Landing.

### üìù PROMPT PARA DOCKER-COMPOSE MAESTRO

```markdown
# üöÄ TAREA: ORQUESTAR LOS 3 SERVICIOS CON DOCKER-COMPOSE

## CONTEXTO
- Backend dockerizado: `gestion-citas/` (Spring Boot + MySQL)
- Frontend dockerizado: `frontend-gestion-citas/` (React + Nginx)
- Landing dockerizada: `landing-page/` (HTML est√°tico + Nginx)

## OBJETIVO
Crear un `docker-compose.yml` maestro que levante los 3 servicios coordinados.

## ESTRUCTURA DE CARPETAS ESPERADA
```
proyecto-clinica-veterinaria/
‚îú‚îÄ‚îÄ docker-compose.yml          ‚Üê ARCHIVO MAESTRO A CREAR
‚îú‚îÄ‚îÄ .env.production             ‚Üê Variables de entorno
‚îú‚îÄ‚îÄ gestion-citas/              ‚Üê Backend
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.yml      ‚Üê Ya existe
‚îú‚îÄ‚îÄ frontend-gestion-citas/     ‚Üê Frontend
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ nginx.conf
‚îî‚îÄ‚îÄ landing-page/               ‚Üê Landing
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ nginx.conf
```

## TAREAS ESPEC√çFICAS

### 1. CREAR DOCKER-COMPOSE.YML MAESTRO
Crear en la ra√≠z del proyecto:

```yaml
version: '3.8'

networks:
  vetclinic-network:
    driver: bridge

volumes:
  mysql-data:
    driver: local

services:
  # ========== BASE DE DATOS ==========
  mysql:
    image: mysql:8.0
    container_name: vetclinic-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "${MYSQL_PORT}:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./gestion-citas/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - vetclinic-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ========== BACKEND ==========
  backend:
    build:
      context: ./gestion-citas
      dockerfile: Dockerfile
    container_name: vetclinic-backend
    restart: unless-stopped
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/${MYSQL_DATABASE}
      SPRING_DATASOURCE_USERNAME: ${MYSQL_USER}
      SPRING_DATASOURCE_PASSWORD: ${MYSQL_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - "${BACKEND_PORT}:8080"
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - vetclinic-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ========== FRONTEND ==========
  frontend:
    build:
      context: ./frontend-gestion-citas
      dockerfile: Dockerfile
      args:
        VITE_API_URL: http://backend:8080/api
    container_name: vetclinic-frontend
    restart: unless-stopped
    ports:
      - "${FRONTEND_PORT}:80"
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - vetclinic-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ========== LANDING PAGE ==========
  landing:
    build:
      context: ./landing-page
      dockerfile: Dockerfile
    container_name: vetclinic-landing
    restart: unless-stopped
    environment:
      FRONTEND_URL: http://frontend:80
    ports:
      - "${LANDING_PORT}:80"
    depends_on:
      - frontend
    networks:
      - vetclinic-network
```

### 2. CREAR .ENV.PRODUCTION
```env
# MySQL
MYSQL_ROOT_PASSWORD=rootSecurePass123
MYSQL_DATABASE=gestion_citas
MYSQL_USER=vetclinic_user
MYSQL_PASSWORD=VetClinic2025!
MYSQL_PORT=3306

# Backend
BACKEND_PORT=8080
JWT_SECRET=clave-super-secreta-jwt-2025-vetclinic

# Frontend
FRONTEND_PORT=3000
VITE_API_URL=http://localhost:8080/api

# Landing
LANDING_PORT=80
```

### 3. CREAR SCRIPTS DE ADMINISTRACI√ìN

**start.sh** (Linux/Mac):
```bash
#!/bin/bash
echo "üöÄ Iniciando Cl√≠nica Veterinaria..."
docker-compose --env-file .env.production up -d
echo "‚úÖ Servicios iniciados:"
echo "   Landing: http://localhost"
echo "   Frontend: http://localhost:3000"
echo "   Backend: http://localhost:8080"
docker-compose ps
```

**start.ps1** (Windows PowerShell):
```powershell
Write-Host "üöÄ Iniciando Cl√≠nica Veterinaria..." -ForegroundColor Green
docker-compose --env-file .env.production up -d
Write-Host "‚úÖ Servicios iniciados:" -ForegroundColor Green
Write-Host "   Landing: http://localhost" -ForegroundColor Cyan
Write-Host "   Frontend: http://localhost:3000" -ForegroundColor Cyan
Write-Host "   Backend: http://localhost:8080" -ForegroundColor Cyan
docker-compose ps
```

**stop.sh** / **stop.ps1**:
```bash
#!/bin/bash
echo "üõë Deteniendo Cl√≠nica Veterinaria..."
docker-compose down
echo "‚úÖ Servicios detenidos"
```

### 4. COMANDOS DE PRUEBA

```bash
# Build todas las im√°genes
docker-compose --env-file .env.production build

# Levantar todos los servicios
docker-compose --env-file .env.production up -d

# Ver logs de todos los servicios
docker-compose logs -f

# Ver logs de un servicio espec√≠fico
docker-compose logs -f backend

# Ver estado de los servicios
docker-compose ps

# Verificar health checks
docker inspect vetclinic-backend | grep -A 10 Health

# Detener todos los servicios
docker-compose down

# Limpiar todo (incluyendo vol√∫menes)
docker-compose down -v
```

### 5. PRUEBAS END-TO-END

```bash
# 1. Verificar MySQL
docker exec -it vetclinic-mysql mysql -uroot -prootSecurePass123 -e "SHOW DATABASES;"

# 2. Verificar Backend
curl http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@clinicaveterinaria.com","password":"admin123"}'

# 3. Verificar Frontend
curl http://localhost:3000

# 4. Verificar Landing
curl http://localhost
```

## CRITERIOS DE √âXITO
- [ ] `docker-compose up -d` ejecuta sin errores
- [ ] Todos los contenedores aparecen como "healthy"
- [ ] MySQL acepta conexiones del backend
- [ ] Backend responde en el puerto 8080
- [ ] Frontend carga en el puerto 3000
- [ ] Landing carga en el puerto 80
- [ ] Landing ‚Üí Frontend ‚Üí Backend flujo completo funciona
- [ ] Login desde frontend autentica contra backend
- [ ] No hay errores de red entre contenedores

## ENTREGABLES
1. `docker-compose.yml` maestro funcional
2. `.env.production` con todas las variables
3. Scripts `start.sh/ps1` y `stop.sh/ps1`
4. README.md con instrucciones de uso
5. Documentaci√≥n de troubleshooting
6. Capturas de pantalla de los 3 servicios funcionando
```

---

## üìç FASE 3: PREPARACI√ìN PARA AZURE (1 D√çA)

### üéØ Objetivo
Adaptar la configuraci√≥n para despliegue en Azure con servicios estudiantiles.

### üìù PLAN DE DESPLIEGUE EN AZURE

```markdown
# üöÄ ESTRATEGIA DE DESPLIEGUE EN AZURE

## SERVICIOS DE AZURE A UTILIZAR

### 1. AZURE DATABASE FOR MYSQL
**Servicio:** Azure Database for MySQL - Flexible Server  
**Tier:** B1ms (1 vCore, 2GB RAM) - Incluido en cr√©dito estudiantil  
**Configuraci√≥n:**
- Backup autom√°tico habilitado
- SSL requerido
- Firewall: permitir IPs de App Services

### 2. BACKEND - AZURE APP SERVICE
**Servicio:** Azure App Service (Linux)  
**Plan:** B1 (1 Core, 1.75GB RAM)  
**Runtime:** Java 17  
**Configuraci√≥n:**
- Deployment: Docker Container
- Registry: Azure Container Registry
- Health check: `/actuator/health`
- Always On: Habilitado

### 3. FRONTEND - AZURE STATIC WEB APPS
**Servicio:** Azure Static Web Apps  
**Plan:** Free (incluido)  
**Configuraci√≥n:**
- Build: React (Vite)
- Output: `dist/`
- API: Vinculada al App Service del backend

### 4. LANDING PAGE - AZURE STATIC WEB APPS
**Servicio:** Azure Static Web Apps (misma instancia que frontend)  
**Plan:** Free  
**Configuraci√≥n:**
- Ruta ra√≠z: Landing page
- Subruta `/app`: Frontend

## ARQUITECTURA FINAL EN AZURE

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Azure Static Web Apps (Free)         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Landing Page (/)                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  http://vetclinic.azurewebsites... ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ              ‚îÇ Redirecci√≥n              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Frontend (/app)                  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  React + Vite                     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ API Calls
‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Azure App Service (B1)                ‚îÇ
‚îÇ   Backend Spring Boot                   ‚îÇ
‚îÇ   http://backend-vetclinic.azure...     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ JDBC
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Azure Database for MySQL (B1ms)      ‚îÇ
‚îÇ   Flexible Server                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## TAREAS DE PREPARACI√ìN

### 1. CREAR AZURE CONTAINER REGISTRY
```bash
# Login en Azure
az login --use-device-code

# Crear Resource Group
az group create \
  --name rg-vetclinic \
  --location eastus

# Crear Container Registry
az acr create \
  --resource-group rg-vetclinic \
  --name vetclinicregistry \
  --sku Basic
```

### 2. CONFIGURAR MYSQL EN AZURE
```bash
# Crear MySQL Flexible Server
az mysql flexible-server create \
  --resource-group rg-vetclinic \
  --name mysql-vetclinic \
  --location eastus \
  --admin-user adminvetclinic \
  --admin-password 'VetClinic2025!' \
  --sku-name B_Standard_B1ms \
  --tier Burstable \
  --storage-size 20 \
  --version 8.0

# Crear base de datos
az mysql flexible-server db create \
  --resource-group rg-vetclinic \
  --server-name mysql-vetclinic \
  --database-name gestion_citas
```

### 3. PUSH BACKEND A ACR
```bash
# Tag imagen
docker tag gestion-citas-backend:latest \
  vetclinicregistry.azurecr.io/backend:latest

# Login en ACR
az acr login --name vetclinicregistry

# Push imagen
docker push vetclinicregistry.azurecr.io/backend:latest
```

### 4. CREAR APP SERVICE PARA BACKEND
```bash
# Crear App Service Plan
az appservice plan create \
  --name plan-vetclinic \
  --resource-group rg-vetclinic \
  --sku B1 \
  --is-linux

# Crear Web App con container
az webapp create \
  --resource-group rg-vetclinic \
  --plan plan-vetclinic \
  --name backend-vetclinic \
  --deployment-container-image-name vetclinicregistry.azurecr.io/backend:latest

# Configurar variables de entorno
az webapp config appsettings set \
  --resource-group rg-vetclinic \
  --name backend-vetclinic \
  --settings \
    SPRING_DATASOURCE_URL="jdbc:mysql://mysql-vetclinic.mysql.database.azure.com:3306/gestion_citas?sslMode=REQUIRED" \
    SPRING_DATASOURCE_USERNAME="adminvetclinic" \
    SPRING_DATASOURCE_PASSWORD="VetClinic2025!" \
    JWT_SECRET="azure-jwt-secret-2025"
```

### 5. DESPLEGAR FRONTEND EN STATIC WEB APPS
```bash
# Instalar extensi√≥n
npm install -g @azure/static-web-apps-cli

# Deploy frontend
cd frontend-gestion-citas
swa deploy \
  --app-location . \
  --output-location dist \
  --api-location "" \
  --env production
```

### 6. DESPLEGAR LANDING EN STATIC WEB APPS
```bash
cd landing-page
swa deploy \
  --app-location . \
  --output-location . \
  --env production
```

## VARIABLES DE ENTORNO PARA AZURE

**.env.azure**:
```env
# MySQL Azure
AZURE_MYSQL_HOST=mysql-vetclinic.mysql.database.azure.com
AZURE_MYSQL_PORT=3306
AZURE_MYSQL_DATABASE=gestion_citas
AZURE_MYSQL_USER=adminvetclinic
AZURE_MYSQL_PASSWORD=VetClinic2025!

# Backend Azure
AZURE_BACKEND_URL=https://backend-vetclinic.azurewebsites.net

# Frontend Azure
AZURE_FRONTEND_URL=https://vetclinic.azurewebsites.net

# JWT
JWT_SECRET=azure-jwt-secret-ultra-secure-2025
```

## CHECKLIST AZURE
- [ ] Cuenta Azure Educaci√≥n activada
- [ ] Resource Group creado
- [ ] Azure Container Registry configurado
- [ ] MySQL Flexible Server creado y accesible
- [ ] Backend desplegado en App Service
- [ ] Frontend desplegado en Static Web Apps
- [ ] Landing desplegada en Static Web Apps
- [ ] Firewall MySQL configurado para App Service
- [ ] SSL/TLS habilitado en MySQL
- [ ] Health checks configurados
- [ ] Logs centralizados en Log Analytics
- [ ] Pruebas E2E exitosas en producci√≥n
```

---

## üìç FASE 4: VALIDACI√ìN FINAL (DESPU√âS DEL DESPLIEGUE)

### üß™ PRUEBAS EN AZURE

```markdown
# CHECKLIST DE VALIDACI√ìN EN PRODUCCI√ìN

## 1. LANDING PAGE
- [ ] Accesible en URL de Azure
- [ ] Estilos CSS cargando correctamente
- [ ] Im√°genes mostr√°ndose
- [ ] Bot√≥n "Acceder" funcional
- [ ] Redirecci√≥n al frontend correcta

## 2. FRONTEND
- [ ] Accesible en URL de Azure
- [ ] P√°gina de login carga
- [ ] Login con credenciales de prueba funciona
- [ ] Dashboard carga datos
- [ ] Navegaci√≥n entre secciones funciona
- [ ] Im√°genes y assets cargan

## 3. BACKEND
- [ ] Health check responde: `/actuator/health`
- [ ] Login API funciona
- [ ] CRUD de citas funciona
- [ ] CRUD de mascotas funciona
- [ ] Permisos por rol validados

## 4. BASE DE DATOS
- [ ] Conexi√≥n desde backend exitosa
- [ ] Datos de prueba cargados
- [ ] Queries funcionando correctamente

## 5. INTEGRACI√ìN E2E
- [ ] Landing ‚Üí Frontend ‚Üí Backend ‚Üí DB flujo completo
- [ ] Login desde frontend autentica en backend
- [ ] CRUD completo funciona end-to-end
- [ ] No hay errores de CORS
- [ ] Performance aceptable (< 3s carga inicial)
```

---

## üìä CRONOGRAMA RESUMIDO

| Fase | Duraci√≥n | Entregable Principal |
|------|----------|---------------------|
| **FASE 1** | 2-3 horas | Frontend + Landing dockerizados y funcionando localmente |
| **FASE 2** | 2 horas | docker-compose.yml maestro orquestando los 3 servicios |
| **FASE 3** | 1 d√≠a | Configuraci√≥n Azure completa + despliegue inicial |
| **FASE 4** | 2 horas | Validaci√≥n E2E en producci√≥n |

---

## üéØ HITOS CR√çTICOS

### ‚úÖ HITO 1: Docker Local Completo
**Criterio:** `docker-compose up -d` levanta los 3 servicios y funcionan juntos

### ‚úÖ HITO 2: Primera Conexi√≥n Frontend-Backend
**Criterio:** Login desde frontend dockerizado autentica contra backend dockerizado

### ‚úÖ HITO 3: Azure Configurado
**Criterio:** Todos los servicios Azure creados y configurados

### ‚úÖ HITO 4: Despliegue Exitoso
**Criterio:** Aplicaci√≥n funcionando end-to-end en Azure

---

## üìù DOCUMENTACI√ìN A GENERAR

1. **README.md principal** con arquitectura del sistema
2. **DOCKER_SETUP.md** con instrucciones de Docker local
3. **AZURE_DEPLOYMENT.md** con pasos de despliegue en Azure
4. **TROUBLESHOOTING.md** con errores comunes y soluciones
5. **API_DOCUMENTATION.md** con endpoints documentados
6. **USER_MANUAL.md** con gu√≠a de usuario final

---

## üö® PUNTOS DE CONTROL

### Antes de avanzar a FASE 2:
- [ ] Frontend se comunica con Backend en Docker
- [ ] Landing redirige correctamente al Frontend

### Antes de avanzar a FASE 3:
- [ ] `docker-compose up -d` funciona sin errores
- [ ] Flujo E2E completo validado localmente

### Antes de considerar FASE 4:
- [ ] Todos los servicios Azure creados
- [ ] Im√°genes Docker subidas a ACR

---

## üí° RECOMENDACIONES FINALES

1. **NO pasar a la siguiente fase** hasta completar la actual
2. **Documentar cada error** encontrado y su soluci√≥n
3. **Hacer commits frecuentes** al final de cada tarea exitosa
4. **Probar en local** antes de subir a Azure
5. **Mantener copias** de las variables de entorno
6. **Usar Azure CLI** para automatizar despliegues

---

## üéâ RESULTADO ESPERADO FINAL

```
üåê Landing Page (Azure Static Web Apps - FREE)
   ‚îî‚îÄ‚ñ∫ http://vetclinic.azurewebsites.net

üì± Frontend React (Azure Static Web Apps - FREE)
   ‚îî‚îÄ‚ñ∫ http://vetclinic.azurewebsites.net/app

‚öôÔ∏è Backend API (Azure App Service - B1)
   ‚îî‚îÄ‚ñ∫ https://backend-vetclinic.azurewebsites.net/api

üóÑÔ∏è Base de Datos (Azure MySQL - B1ms)
   ‚îî‚îÄ‚ñ∫ mysql-vetclinic.mysql.database.azure.com
```

**Todo funcionando de forma integrada, aprovechando cr√©dito estudiantil de Azure.**

---

**üìå √öltima actualizaci√≥n:** 2025-10-22  
**üîí Versi√≥n:** 1.0 - Estrategia de orquestaci√≥n completa  
**‚úÖ Estado:** Listo para ejecutar FASE 1